
/**
 *
 * @author Matias Mirabelli <lumen.night@gmail.com>
 * @since 0.0.1
 */
make.JavaCompiler = function (workspace) {

  /**
   * Wrapper function for the native process#spawn. It launches a new process
   * and returns a ChildProcess object.
   *
   * @param {String} command Command line to execute. Cannot be null or empty.
   * @param {String[]} [args] List of arguments passed to the command. Can be
   *    null.
   * @param {Object} [options] Options for the new process. Can be null.
   */
  var spawn = require("child_process").spawn;

  /**
   * NodeJS Path library. Cannot be null.
   */
  var path = require("path");

  /** NodeJS File System library. Cannot be null.
   */
  var fs = require("fs");

  /** Node's util library. */
  var util = require("util");

  return Object.create(Mixin(new make.Compiler(),
  /** @lends make.JavaCompiler */
  {

    /**
     * Processes the specified query and populates the results in the same
     * object. This operation is asynchronous.
     *
     * @param {make.Workspace} workspace Workspace to build. Cannot be null.
     * @param {Function} callback Function invoked after processing. Can
     *    be null.
     */
    build : function(workspace, callback) {
      this.prepare(workspace, function(files, errors) {
        if (errors) {
          callback(workspace, errors);
        }

        this.compile(files, function(errors) {
          errors.each(function(error) {
            if (error.source) {
              error.source = path.basename(error.source);
            }
          });

          callback(workspace, errors);
        }.bind(this));
      }.bind(this));
    },

    /**
     * Determines the working root path for the query.
     *
     * @param {VM.Query} query Query to get the root working directory. Cannot
     *    be null.
     * @return {String} A valid directory to write query information and buffers.
     */
    getRootPath : function(query) {
      return "/tmp/common-vm";
    },

    /**
     * Prepares the specified query to invoke the compiler performing the
     * following actions:
     * <ul>
     *  <li>Deletes old generated files.</li>
     *  <li>Creates or replaces source files in the query working
     *    directory.</li>
     *  <li>Prepares the classpath.</li>
     * </ul>
     */
    prepare : function(workspace, callback) {
      var rootDir = this.getRootPath(workspace);
      var buffers = workspace.getBuffers();
      var files = [];

      var prepare = function(rawBuffer) {
        if (!rawBuffer) {
          console.log("No more buffers to prepare.");
          this.deleteOldBinaries(files);
          callback(files);

          return;
        }

        try {
          console.log("Creating buffer: " + rawBuffer.name);

          var buffer = make.Buffer.newInstance(make.JavaFileBuffer, rawBuffer);

console.log("Creating directory: " + buffer.name);
          files.push(buffer.getFile(rootDir));

          console.log("No more buffers to prepare.");
          buffer.save(rootDir, prepare.curry(buffers.shift()));
          console.log("No more buffers to prepare.");
        } catch(cause) {
          callback([], cause);
        }
      }.bind(this);

      prepare(buffers.shift());
    },

    /**
     * Deletes all generated class files related to the specified source files,
     * if they exists.
     *
     * @param {make.Workspace} workspace Workspace containing the list
     *    of source files. Cannot
     *    be null.
     */
    deleteOldBinaries : function(files) {
      console.log("Removing old files:");
      console.log(files);

      files.each(function(file) {
        var binaryFile = path.join(path.dirname(file),
          path.basename(file, ".java") + ".class");

        console.info("Removing file: " + binaryFile);

        try {
          fs.unlinkSync(binaryFile);
        } catch(ex) {
          console.error("Couldn't remove file: " + binaryFile +
              " (" + ex.message + ")");
        }
      });
    },

    /**
     * Compiles the specified list of files. Files will be compiled in the same
     * context.
     *
     * @param {String[]} Java source files to compile. Cannot be null.
     * @param {Function} diagnosticCollectorCallback Function invoked when
     *    the compiler finishes. The list of errors will be passed
     *    as parameter. Cannot be null.
     */
    compile : function(files, diagnosticCollectorCallback) {
      var compilerBin = VM.io.getToolCommand("java-compiler",
        "-jar-with-dependencies");
      var result = "";

      console.log("Invoking javac: " + ["-jar", compilerBin].concat(files)
          .join(" "));

      java = spawn("java", ["-jar", compilerBin].concat(files));

      java.stdout.on('data', function (data) {
        result += data;
      });

      java.stderr.on('data', function (data) {
        console.error('stderr: ' + data);
        result = JSON.stringify([ new Error(data) ] );
      });

      java.on('exit', function (code) {
        if (code === 0) {
          var errors = JSON.parse(result);
          if (errors.length) {
            console.log("Compilation failed with errors: ");
            errors.each(function(error) {
              console.log(util.inspect(error));
            });
          } else {
            console.log("Compilation succeed without errors.");
          }
          diagnosticCollectorCallback(errors);
        } else {
          console.log('child process exited with code ' + code);
        }
      });
    }
  }));
};
